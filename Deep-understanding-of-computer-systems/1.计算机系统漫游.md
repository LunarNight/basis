系统由硬件和软件组成，它们共同工作来运行应用程序。  
示例程序：hello.c  
```
1 #include<stdio.h>  
2 int main()  
3 {  
4    printf("hello,world\n");  
5 }  
```  
我们通过跟踪hello程序的生命周期来开始对系统的学习——它从被程序员创建,到在系统上运行,输出简单的消息,然后终止.  
我们将沿着这个程序的生命周期,简要地介绍一些逐步出现的关键概念,专业术语和组成部分.后面的章节将围绕这些内容展开.  
## 1.1 信息就是位+上下文  
   hello程序的生命周期是从一个**源程序**(或者说是**源文件**)开始的.即：hello.c  
   **源程序**实际上就是一个由值0和1组成的位(bit)序列，8个位被组织成一组,称为**字节**  
   每个字节表示程序中某个字符文本  
   大部分的现代系统都使用ASCII标准来表示文本字符,即:用一个唯一的单字节大小的整数值来表示每个字符.  
   hello.c程序以字节序列的方式存储在文件里.每个字节都有一个整数值,每个整数值对应于某个字符.  
   像hello.c这样只由ASCII字符构成的文件称为**文本文件**,所有其它的文件都称为**二进制文件**.  
   hello world部分程序的ASCII码表示:  
   ```
   #    i   n   c    l   u   d   e   <sp>  
   35  105 110  99  108 117 100 101   32  
   ```  
   系统中所有的信息——包括磁盘文件,存储器中的程序,存储器中存放的用户数据以及网络上传送的数据,都是由一串位表示的.  
   区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.  
   比如,在不同的上下文中,一个同样的字节序列可能表示一个整数,浮点数,字符串或者机器指令.  
## 1.2 程序被其他程序翻译成不同的格式  
   hello程序的生命周期从高级C语言程序开始,为了在系统上运行hello.c程序,每条c语句都必须被其他程序转化为一系列的**低级机器语言指令**.  
   这些指令按照**可执行目标程序**的格式打好包,并以**二进制磁盘文件**的形式存放起来.  
   **目标程序**也可称为**可执行目标文件**  
   UNIX系统上,源文件到目标文件的转化是由编译器驱动程序完成的:  
   unix>gcc -o hello hello.c  
   GCC编译器驱动程序读取源文件hello.c,将它翻译为可执行目标文件hello.编译过程分为四个阶段  
   执行这四个阶段的程序(**预处理器**,**编译器**,**汇编器**,**链接器**)一起构成了**编译系统**  
   hello.c源程序(文本)->预处理器(cpp)->hello.i被修改的源程序(文本)->编译器(ccl)->hello.s汇编程序(文本)->编译器(as)  
   ->hello.o可重定位目标程序(二进制)->链接器(ld)->hello可执行目标程序(二进制)  
   1. **预处理阶段**:预处理器读取系统头文件内容，并把它直接插入到程序文本中，得到另一个C程序;  
   2. **编译阶段**:编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个**汇编语言程序**;  
   3. **汇编阶段**:汇编器将hello.s翻译成机器语言的指令,并把这些指令打包成一种叫做**可重定位目标程序**的格式,结果保存在目标文件hello.o中.hello.o文件是一个二进制文件,它的字节编码是机器语言指令而不是字符.如果我们在文本编辑器中打开它,看到的将会是一堆乱码.  
   4. **链接阶段**:链接器将已经编译好的printf.o目标文件合并到hello.o程序中.得到hello文件,一个**可执行目标文件**,被加载到内存中,由系统执行.  
## 1.3 了解编译器如何工作的益处  
   1. 优化程序性能  
   2. 理解链接时出现的错误  
   3. 避免安全漏洞  
## 1.4 处理器读并解释存储在存储器中的指令  
   此刻,hello.c源程序已经被编译成了可执行目标文件hello,并存放在磁盘上.   
   在UNIX系统上运行该可执行文件,将它的文件名输入到称为外壳(shell)(一个命令解释器)的应用程序中:  
   ```
   unix> ./hello  
   hello,world  
   unix>  
   ```  
### 1.4.1 系统的硬件组成  
1. **总线**:贯穿整个系统的一组电子管道.总线信息字节并负责在各个部件间传递.总线通常被设计成传送定长的**字节块**,也就是**字**.  
               字中的字节数(即:**字长**)是一个基本的系统参数.总线每次只传送一个字.现在大多数机器字长为4个字节(32位)  
2. **I/O设备**:输入/输出设备是系统与外部世界的联系通道.  
   作为用户输入的键盘和鼠标,作为用户输出的显示器,用于长期存储数据和程序的磁盘驱动器(磁盘).  
   每个I/O设备都通过一个控制器或适配器与I/O总线相连.    
3. **主存**:主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据.  
            从物理上来说,主存是一组**动态随机存取存储器**(DRAM)芯片组成的.  
            从逻辑上来说,存储器是一个线性的字节数组,每个字节都有其唯一的地址(即数组索引),这些地址从零开始.  
            组成程序的每条机器指令都由不同数量的字节构成.  
            short类型的数据需要2个字节;int,float,long类型的数据需要4个字节,而double类型的数据需要8个字节.  
4. **处理器**:**中央处理单元(CPU)**的简称,是解释(或执行)存储在主存中指令的引擎.其核心是一个字长的存储设备(或寄存器),称为**程序计数器(PC)**.在任何时刻,PC都指向主存中的某条机器语言指令(即含有该条指令的地址).  
CPU在指令的要求下可能会指向以下操作:加载,存储,操作,跳转.  
   
### 1.4.2 运行hello程序  
初始时,外壳程序执行它的指令，等待我们输入一个命令.当我们在键盘上输入字符串" ./hello"后,外壳程序将字符逐一读入寄存器,再把它存放到存储器中.当我们在键盘上敲回车键时,外壳程序就知道我们已经结束了命令的输入.然后外壳执行一系列指令来加载可执行文件hello文件,将hello目标文件中的代码和数据复制到主存.数据包括最终会被输出的字符串"hello,world\n".  
一旦目标文件hello中的代码和数据被加载到主存,处理器就开始执行hello程序的main程序中的机器语言指令.这些指令将"hello,world\n"字符串中的字节从主存复制到寄存器文件,再从寄存器文件复制到显示设备,最终显示在屏幕上.  
## 1.5 高速缓存至关重要  
 **高速缓存存储器**(简称高速缓存):用来存放近期可能会需要的信息.  
 利用高速缓存的**局部性原理**,即程序具有访问局部区域里的数据和代码的趋势.通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储操作都能在快速的高速缓存中完成.
## 1.6 存储设备形成层次结构  
在处理器和一个又大又慢的设备(例如主存)之间插入一个更快更小的存储设备(例如高速缓存)的想法已经成为了一个普遍观念.实际上,每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**.在这个层次结构中,从上至下,设备变得访问速度越来越慢,容量越来越大,并且每字节的造价也越来越便宜.  
存储器层次结构的**主要思想**:一层上的存储器作为第一层存储器的高速缓存.因此,寄存器文件就是L1的高速缓存,L1是L2的高速缓存,L2是L3的高速缓存,L3是主存的高速缓存,而主存又是磁盘的高速缓存.在某些具有分布式文件系统的网络系统中,本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存.  
## 1.7 操作系统管理硬件
 **操作系统**:把它看成应用程序和硬件之间插入的一层软件.所有应用程序对硬件的操作尝试都必须通过操作系统.  
 操作系统有两个**功能**:  
 1. 防止硬件被失控的应用程序滥用.  
 2. 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备.  
 
操作系统通过几个基本的抽象概念(进程,虚拟存储器,文件)来实现这两个功能.  
文件是对I/O设备的抽象表示,虚拟存储器是对主存和磁盘I/O设备的抽象表示,进程则是对**处理器,主存和I/O设备**的抽象表示.
### 1.7.1 进程
**进程**是操作系统对一个正在运行的程序的一种抽象.  
**并发运行**:一个进程的指令和另一个进程的指令是交错进行的.在大多数系统中,需要运行的进程数是多于可以运行它们的CPU个数的.一个CPU看上去都像是在并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的机制称为**上下文切换**.  
操作系统保持跟踪进程运行所需的所有状态信息.这种状态,也就是**上下文**,它包括许多信息,例如PC和寄存器文件的当前值,以及主存的内容.任何时刻单处理器系统都只能执行一个进程的代码.当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行**上下文切换**:即保存当前进程的上下文,恢复新进程的上下文,然后将控制权传递到新进程.新进程就会从上次停止的地方开始.  
实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作.
### 1.7.2 线程
 在现代系统中,一个进程实际上是由多个称为**线程**的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据.  
 多线程之间比多进程之间更容易共享数据,线程一般来说都比进程高效.  
 ### 1.7.3 虚拟存储器
 虚拟存储器是一个抽象概念,它为每个进程提供了一个假象,即每个进程都独占地使用主存.每个进程看到的是一致的存储器,称为**虚拟地址空间**.
 
