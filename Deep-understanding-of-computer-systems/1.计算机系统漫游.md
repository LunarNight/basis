系统由硬件和软件组成，它们共同工作来运行应用程序。  
示例程序：hello.c  
```
1 #include<stdio.h>  
2 int main()  
3 {  
4    printf("hello,world\n");  
5 }  
```  
我们通过跟踪hello程序的生命周期来开始对系统的学习——它从被程序员创建,到在系统上运行,输出简单的消息,然后终止.  
我们将沿着这个程序的生命周期,简要地介绍一些逐步出现的关键概念,专业术语和组成部分.后面的章节将围绕这些内容展开.  
## 1.1 信息就是位+上下文  
   hello程序的生命周期是从一个**源程序**(或者说是**源文件**)开始的.即：hello.c  
   **源程序**实际上就是一个由值0和1组成的位(bit)序列，8个位被组织成一组,称为**字节**  
   每个字节表示程序中某个字符文本  
   大部分的现代系统都使用ASCII标准来表示文本字符,即:用一个唯一的单字节大小的整数值来表示每个字符.  
   hello.c程序以字节序列的方式存储在文件里.每个字节都有一个整数值,每个整数值对应于某个字符.  
   像hello.c这样只由ASCII字符构成的文件称为**文本文件**,所有其它的文件都称为**二进制文件**.  
   hello world部分程序的ASCII码表示:  
   ```
   #    i   n   c    l   u   d   e   <sp>  
   35  105 110  99  108 117 100 101   32  
   ```  
   系统中所有的信息——包括磁盘文件,存储器中的程序,存储器中存放的用户数据以及网络上传送的数据,都是由一串位表示的.  
   区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.  
   比如,在不同的上下文中,一个同样的字节序列可能表示一个整数,浮点数,字符串或者机器指令.  
## 1.2 程序被其他程序翻译成不同的格式  
   hello程序的生命周期从高级C语言程序开始,为了在系统上运行hello.c程序,每条c语句都必须被其他程序转化为一系列的**低级机器语言指令**.  
   这些指令按照**可执行目标程序**的格式打好包,并以**二进制磁盘文件**的形式存放起来.  
   **目标程序**也可称为**可执行目标文件**  
   UNIX系统上,源文件到目标文件的转化是由编译器驱动程序完成的:  
   unix>gcc -o hello hello.c  
   GCC编译器驱动程序读取源文件hello.c,将它翻译为可执行目标文件hello.编译过程分为四个阶段  
   执行这四个阶段的程序(**预处理器**,**编译器**,**汇编器**,**链接器**)一起构成了**编译系统**  
   hello.c源程序(文本)->预处理器(cpp)->hello.i被修改的源程序(文本)->编译器(ccl)->hello.s汇编程序(文本)->编译器(as)  
   ->hello.o可重定位目标程序(二进制)->链接器(ld)->hello可执行目标程序(二进制)  
   1. **预处理阶段**:预处理器读取系统头文件内容，并把它直接插入到程序文本中，得到另一个C程序;  
   2. **编译阶段**:编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个**汇编语言程序**;  
   3. **汇编阶段**:汇编器将hello.s翻译成机器语言的指令,并把这些指令打包成一种叫做**可重定位目标程序**的格式,结果保存在目标文件hello.o中.hello.o文件是一个二进制文件,它的字节编码是机器语言指令而不是字符.如果我们在文本编辑器中打开它,看到的将会是一堆乱码.  
   4. **链接阶段**:链接器将已经编译好的printf.o目标文件合并到hello.o程序中.得到hello文件,一个**可执行目标文件**,被加载到内存中,由系统执行.  
## 1.3 了解编译器如何工作的益处  
   1. 优化程序性能  
   2. 理解链接时出现的错误  
   3. 避免安全漏洞  
## 1.4 处理器读并解释存储在存储器中的指令  
   此刻,hello.c源程序已经被编译成了可执行目标文件hello,并存放在磁盘上.   
   在UNIX系统上运行该可执行文件,将它的文件名输入到称为外壳(shell)(一个命令解释器)的应用程序中:  
   ```
   unix> ./hello  
   hello,world  
   unix>  
   ```  
### 1.4.1 系统的硬件组成  
1. **总线**:贯穿整个系统的一组电子管道.总线信息字节并负责在各个部件间传递.总线通常被设计成传送定长的**字节块**,也就是**字**.  
               字中的字节数(即:**字长**)是一个基本的系统参数.总线每次只传送一个字.现在大多数机器字长为4个字节(32位)  
2. **I/O设备**:输入/输出设备是系统与外部世界的联系通道.  
   作为用户输入的键盘和鼠标,作为用户输出的显示器,用于长期存储数据和程序的磁盘驱动器(磁盘).  
   每个I/O设备都通过一个控制器或适配器与I/O总线相连.    
3. **主存**:主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据.  
            从物理上来说,主存是一组**动态随机存取存储器**(DRAM)芯片组成的.  
            从逻辑上来说,存储器是一个线性的字节数组,每个字节都有其唯一的地址(即数组索引),这些地址从零开始.  
            组成程序的每条机器指令都由不同数量的字节构成.  
            short类型的数据需要2个字节;int,float,long类型的数据需要4个字节,而double类型的数据需要8个字节.  
4. **处理器**:**中央处理单元(CPU)**的简称,是解释(或执行)存储在主存中指令的引擎.其核心是一个字长的存储设备(或寄存器),称为**程序计数器(PC)**.在任何时刻,PC都指向主存中的某条机器语言指令(即含有该条指令的地址).  
CPU在指令的要求下可能会指向以下操作:加载,存储,操作,跳转.  
   
### 1.4.2 运行hello程序  
初始时,外壳程序执行它的指令，等待我们输入一个命令.当我们在键盘上输入字符串" ./hello"后,外壳程序将字符逐一读入寄存器,再把它存放到存储器中.当我们在键盘上敲回车键时,外壳程序就知道我们已经结束了命令的输入.然后外壳执行一系列指令来加载可执行文件hello文件,将hello目标文件中的代码和数据复制到主存.数据包括最终会被输出的字符串"hello,world\n".  
一旦目标文件hello中的代码和数据被加载到主存,处理器就开始执行hello程序的main程序中的机器语言指令.这些指令将"hello,world\n"字符串中的字节从主存复制到寄存器文件,再从寄存器文件复制到显示设备,最终显示在屏幕上.  
## 1.5 高速缓存至关重要  
 **高速缓存存储器**(简称高速缓存):用来存放近期可能会需要的信息.  
 利用高速缓存的**局部性原理**,即程序具有访问局部区域里的数据和代码的趋势.通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储操作都能在快速的高速缓存中完成.
## 1.6 存储设备形成层次结构  
在处理器和一个又大又慢的设备(例如主存)之间插入一个更快更小的存储设备(例如高速缓存)的想法已经成为了一个普遍观念.实际上,每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**.在这个层次结构中,从上至下,设备变得访问速度越来越慢,容量越来越大,并且每字节的造价也越来越便宜.  
存储器层次结构的**主要思想**:一层上的存储器作为第一层存储器的高速缓存.因此,寄存器文件就是L1的高速缓存,L1是L2的高速缓存,L2是L3的高速缓存,L3是主存的高速缓存,而主存又是磁盘的高速缓存.在某些具有分布式文件系统的网络系统中,本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存.  
## 1.7 操作系统管理硬件
 **操作系统**:把它看成应用程序和硬件之间插入的一层软件.所有应用程序对硬件的操作尝试都必须通过操作系统.  
 操作系统有两个**功能**:  
 1. 防止硬件被失控的应用程序滥用.  
 2. 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备.  
 
操作系统通过几个基本的抽象概念(进程,虚拟存储器,文件)来实现这两个功能.  
文件是对I/O设备的抽象表示,虚拟存储器是对主存和磁盘I/O设备的抽象表示,进程则是对**处理器,主存和I/O设备**的抽象表示.
### 1.7.1 进程
**进程**是操作系统对一个正在运行的程序的一种抽象.  
**并发运行**:一个进程的指令和另一个进程的指令是交错进行的.在大多数系统中,需要运行的进程数是多于可以运行它们的CPU个数的.一个CPU看上去都像是在并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的机制称为**上下文切换**.  
操作系统保持跟踪进程运行所需的所有状态信息.这种状态,也就是**上下文**,它包括许多信息,例如PC和寄存器文件的当前值,以及主存的内容.任何时刻单处理器系统都只能执行一个进程的代码.当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行**上下文切换**:即保存当前进程的上下文,恢复新进程的上下文,然后将控制权传递到新进程.新进程就会从上次停止的地方开始.  
实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作.
### 1.7.2 线程
 在现代系统中,一个进程实际上是由多个称为**线程**的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据.  
 多线程之间比多进程之间更容易共享数据,线程一般来说都比进程高效.  
### 1.7.3 虚拟存储器  
 虚拟存储器是一个抽象概念,它为每个进程提供了一个假象,即每个进程都独占地使用主存.每个进程看到的是一致的存储器,称为**虚拟地址空间**.  
 在Linux中,地址空间的最上面的区域是为操作系统中的代码和数据保留的,这对所有进程来说都是一样的.地址空间的底部区域存放用户进程定义的代码和数据.  
 从最低的地址开始,逐步介绍虚拟地址的每个区:  
 1. **程序代码和数据**:代码是从同一固定地址开始,紧接着的是和C全局变量相对应的数据位置.代码和数据区是直接按照可执行目标文件的内容初始化的.  
 2. **堆**:代码和数据区后紧随着的是运行时堆.代码和数据区是在进程一开始运行时就被规定了大小,而堆可以在运行时动态地扩展和收缩,例如调用malloc和free这样的C标准库函数.  
 3. **共享库**:大约在地址空间的中间部分的一块区域,用来存放像C标准库和数学库这样共享库的代码和数据.  
 4. **栈**: 位于用户虚拟地址空间顶部的是**用户栈**,编译器用它来实现函数调用.用户栈在程序执行期间可以动态地扩展和收缩.  
 5. **内核虚拟存储器**:内核总是驻留在内存中,是操作系统的一部分.地址空间顶部的区域是为内核保留的,不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.  
### 1.7.4 文件  
 文件就是字节序列.每个I/O设备,包括磁盘,键盘,显示器,甚至网络,都可以视为文件.  
 它向应用程序提供了一个统一的视角,来看待系统中可能含有的所有各式各样的I/O设备.  
## 1.8 系统之间利用网络通信  
 现代系统经常通过网络和其他系统连接到一起.从一个单独的系统来看,网络可视为一个I/O设备.  
 当系统从主存将一串字节复制到网络适配器时,数据流经过网络到达另一台机器,而不是其他地方,例如本地磁盘驱动器.相似地,系统可以读取从其他机器发送过来的数据,并把数据复制到自己的主存.  
 像电子邮件,即时通信,万维网,FTP和Telnet这样的应用都是基于**网络复制信息**的功能.  
## 1.9 重要主题  
## 1.9.1 并发和并行  
 **并发**:指一个同时具有多个活动的系统.  
 **并行**:用并发使一个系统运行得更快.并行可以在计算机系统的多个抽象层次上运用.  
 按照系统层次结构中由高到底的顺序介绍三个层次.  
 1. 线程级并发  
 使用线程我们能够在一个进程中执行多个控制流.  
 **超线程**:同时多线程,是一项允许一个CPU执行多个控制流的技术.  
 所有的处理器：单处理器;多处理器(多核,超线程的).  
 2. 指令级并行  
 处理器可以同时执行多条指令的属性称为**指令级并行**.  
 3. 单指令,多数据并行(SIMD并行)  
 允许一条指令产生多个可以并行执行的操作.  
 提高处理影像,声音和视频数据应用的执行速度.  
 ### 1.9.2 计算机系统中抽象的重要性  
 例如,为一组函数规定一个简单的应用程序接口(API)就是一个很好的编程习惯,程序员无需了解它内部的工作便可以使用这些代码.不同的编程语言提供不同形式和等级的抽象支持,例如Java类的声明和C语言的函数原型.  
 增加一个新的抽象,**虚拟机**:它提供对整个计算机(包括操作系统,处理器和程序)的抽象. 
 
 
