# 浏览器缓存  
## 6.1 别忘了浏览器  
 实际上,当我们通过浏览器打开一个Web页面的时候,浏览器需要从Web服务器下载一系列的内容,包括HTML网页,图片,脚本,样式表等,并且将它们存放在浏览器的缓存中.  
一旦Web服务器上的一部分内容存在于用户浏览器缓存中,那么至少对于这个用户而言,如果请求同样的内容,便可能不需要再次从服务器获取,直接从浏览器缓存中拿来即可.一个典型的例子是:当我在线试听MP3音乐时,第一次会等待一定时间的下载缓冲,而随后再次试听的时候,便可以迅速开始播放,这实际上便是直接读取缓存在本地的MP3文件.  

#### 浏览器不只是用户的  
 浏览器是用户安装在PC上的软件,而Web站点所拥有的只是数据中心的服务器.但是如果你换一个角度,把浏览器想象成为Web站点分派到千家万户的缓存管理器,那么成千上万的浏览器就像在为你免费打工,如果你懂得有效利用它的话.  

我们要把握的一个**原则**:尽可能地让Web站点的内容缓存在用户浏览器中.  
这样将在一定程度上减少了服务器的计算开销,而且也避免了有些内容由于不必要的重复传输而带来的宽带浪费,出于环保主义的考虑,我们都应该特别重视这一点.根据能量守恒定律,从服务器发送的数据越多,消耗的能量越大,散热和辐射都在随之增加,而我们仅仅需要将这些内容缓存在浏览器就可以改善这一现状.  

#### 缓存放在哪里  
 浏览器一般会在用户的文件系统中创建一个目录,用于存放缓存文件,并给每个缓存文件打上一些必要的标记,比如过期时间等.  
 既然是缓存,那么过期检查肯定是少不了的,那么浏览器是如何完成的呢?浏览器和Web服务器进行沟通的唯一途径便是HTTP,那么如果浏览器希望了解本地的内容是否过期,当然也得通过HTTP和服务器进行沟通.可见,**有效地使用浏览器缓存**,其**本质**在于**对HTTP协议缓存**部分的深入理解,下面的内容围绕这部分内容展开,同时这也是后面探讨Web服务器缓存和反向代理缓存的必备知识.  

## 6.2 缓存协议  
 我们都知道,服务器端的动态内容缓存包括缓存内容的创建,存储,以及过期检查等一系列过程,它们都可以由诸如PHP这样的服务器端动态程序来实现.然而,对于浏览器缓存,就完全不是那么回事了,缓存内容存储在浏览器本地,而内容由Web服务器生成,任何一方都不可能独立完成这一系列过程,所以它们之间必须有一种沟通机制,这就是HTTP中的**缓存协商**.  

#### 如何协商  
 协商的过程:首先,当浏览器向Web服务器请求一些内容时,Web服务器需要告诉浏览器哪些内容可以被缓存,一旦浏览器知道某个内容可以缓存后,下次当浏览器需要请求这个内容时,它便不会直接向服务器请求完整内容,而是询问服务器是否可以使用本地的缓存,服务器在收到浏览器的询问后需要作出果断的回应,到底是允许浏览器使用本地缓存还是将最新的内容传回浏览器.  

#### 做好协商的准备  
 动态内容本身并不受浏览器缓存机制的排斥,因为浏览器和Web服务器通过HTTP通信,它们并不关心这些内容是否在服务器上动态生成,所以只要**HTTP头信息**中包含相应的缓存协商协议,动态内容一样可以被浏览器缓存,它和静态内容没什么两样.另外,我们刚刚所说的都是基于GET类型请求的情况,而对于POST类型的请求,浏览器一般不启用本地缓存,对此我们不讨论.  

使用**基于最后修改时间的缓存协商**存在一些缺点.比如:有时候一些文件需要频繁的更新,但是内容可能并没有变化,那么如果采用基于最后修改时间的缓存协商,那么每次文件的修改时间变化后,不论内容是否真的变化,浏览器都会重新获取全部内容;再比如,同一个文件存储在多台Web服务器上,用户的请求在这些服务器之间轮询,实现负载均衡,而这些服务器上同一个文件的最后修改时间很难保证完全相同,这便会导致用户的请求每次切换到新的服务器时就需要重新获取所有内容.这时候,如果使用直接标记内容的某种ETag算法,就可以避免这些问题.  

原本使用服务器端动态缓存的动态内容,在使用浏览器缓存后,能否获得较大的吞吐率提升,关键在于是否能够避免一些额外的计算开销.当然,对于本身没有使用任何服务器端缓存的动态内容,使用浏览器缓存必然会有较大的吞吐率提升.  

浏览器缓存只是针对它所属的用户有效,而服务器端的缓存是针对所有用户有效.  

浏览器存在的意义并不仅仅在于吞吐率的提升,使用浏览器缓存后,宽带使用也会大大降低,即不需要购买太大的独享带宽.二者的共同作用就是浏览器缓存带来的最大价值.  

## 6.3 彻底消灭请求  
 HTTP缓存的目的就是要彻底消灭不必要的请求,也许你很疑惑:之前的缓存协商为什么为什么非要和Web服务器沟通呢?只要在浏览器缓存中标记出过期时间不就可以了么?  

#### 浏览器缓存截止期  
 HTTP中还有另一个标记,那就是**Expires**,它告诉浏览器该内容在何时过期,暗示浏览器在该内容过期之前不需要再询问服务器,而直接使用本地缓存即可.这样做的**好处**显而易见:一旦浏览器丝毫不用请求服务器,那将完全节省了宽带和服务器处理等开销,可谓皆大欢喜.  

浏览器一旦看到某个内容附带Expires标记后,便拥有了极大的权利,它无需在过期之前每次都询问服务器,完全可以自作主张,而Last—Modified标记让浏览器感到拘束,它们不得不每次都询问服务器,即便它们认为这样做毫无意义.  

对于**静态内容**,Web服务器在默认情况下不会开启Expires标记的支持,我们需要进行一定的配置.对于**动态内容**,Expires仍然需要程序自身来添加,类似于之前的Last_Modified.  

#### 如何请求页面  
 对于主流浏览器一般有以下三种请求页面的方法:  
 1. Ctrl+F5.**强制刷新**,它使得网页以及其中的所有组件都直接向Web服务器发送请求,并且不使用缓存协议,这样的目的是获取所有内容的最新版本.你也可以按住Ctrl键然后单击浏览器的刷新按钮获得同样的效果.实际使用中,很少会有用户这样操作.  
 2. F5.**一般的刷新**,我们经常使用,它等同于单击浏览器的刷新按钮.它允许浏览器在请求中附加必要的缓存协商,但不允许浏览器直接使用本地缓存,也就是说,它能够让Last_Modified发挥效果,但是对Expires无效.  
 3. **单击浏览器地址栏的"转到"按钮或者通过超链接跳到此页.**这种方式使用最多,还有一种方式等同于这种方式,因为它没有"转到"按钮.这几种方式允许浏览器以最少的请求来获取网页的数据,浏览器会对所有没过期的内容直接使用本地缓存,所以,Expires标记只对这种方式有效,以后你不用在按了F5键后对浏览器没有使用本地缓存感到奇怪.  

#### 适应本地的过期时间  
 到目前为止,还存在一个问题,通过Expires指定的过期时间,是来自于Web服务器的系统时间,如果用户本地的时间和服务器时间不一致的话,那一定会影响到本地缓存的有效期检查.幸运的是,HTTP/1.1中还有一个标记用于弥补Expires的不足,那就是Cache-Control.值得一提的是,目前主流浏览器都将HTTP/1.1作为首选,所以当HTTP响应头中同时含有Expires和Cache-Control时,浏览器会优先考虑Cache-Control.对于没有Cache-Control的情况,浏览器则会服从Expires的指示.  

