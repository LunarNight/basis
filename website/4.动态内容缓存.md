# 动态内容缓存  
 以上三章我们将目光聚焦在Web服务器本身,改进I/O模型和并发策略带来的性能提升让我们激动不已.  
 
然而,Web站点不仅仅只提供单调的**静态文件**,更多的是**动态内容,**比如动态网页,动态图片,Web服务等,它们通常在Web服务器端进行计算,生成HTML,并返回给用户.与此同时,它们在生成HTML的过程中,不可避免涉及了更多的CPU计算和I/O操作,这已经超出了Web服务器本身,比如访问数据库涉及数据库服务器的CPU计算和磁盘I/O操作,以及与数据库服务器通信的网络I/O操作,同样的情况也发生在调用WebAPI,比如通过twitterAPI获取资料.  

不幸的是,通常这些操作都不是异步的,我们必须等待.  
## 4.1 重复的开销  
 一个涉及到数据库连接操作和SQL查询的动态网页有时时间开销会非常大.但是我们发现大多数时候,动态网页在多次请求访问数据时的计算结果几乎没有变化,那为什么要重复计算呢?通过**缓存**,我们甚至可以完全砍掉它所用的时间.   
## 4.2 缓存与速度  
 在这里,我们所指的是由动态内容自行实现的缓存机制,包括整夜缓存,局部缓存,数据缓存等,除此之外还有代码解释器缓存,Web服务器缓存等.  

**缓存的目的**:把需要花费昂贵开销的计算结果保存起来,在以后需要的时候直接取出,而避免重复计算,一切缓存的**本质**都是如此.  

不过凡是使用缓存,都一定要意识到命中率的重要性,因为毕竟缓存的管理逻辑增加了新的开销.  
## 4.3 页面缓存  
 按照缓存的动机,我们将动态内容的计算结果进行缓存,并在随后需要的时候直接取出返回给用户.对于**动态网页**来说,缓存的内容实际上就是动态网页输出的HTML,我们称为页面缓存,而对于其他动态内容,比如**动态图片或动态XML数据**,我们也可以将它们的输出结果整体进行缓存,其实现机制和动态网页是一样的.  

对于动态内容缓存的具体方法,也许你在使用Smarty的模板框架,或者使用Cakephp,Django,Zend等MVC框架,不管它们支持多么丰富的特性,有一点是相同的,就是将**视图和控制器**进行分离,这样便可以让控制器自身拥有缓存控制权,从而提高非常灵活的缓存控制方法.  

#### 缓存持久化与查找  
 通常,我们将动态内容的缓存存储在磁盘上,通常磁盘有足够而且廉价的空间来存储大量的文件,我们不用担心因为空间的限制而淘汰缓存,这是一种比较简单也容易部署的方法.  

我们知道,一个动态网页根据URL参数的不同,会展示出多种不同的结果,而每一种结果都必须生成对应的缓存文件.比如:Smarty支持缓存分类,这样Smarty会根据不同参数生成不同的缓存文件,它完成得非常出色.  

但是,如果缓存文件非常多的话,cache目录下会拥挤大量的文件.即使你的站点规模不大,也有可能在不长的时间里毫不费力地积累数万个缓存文件,并且糟糕的是这些缓存文件不会自己删除.一旦cache目录下的文件数量达到数以万计后,CPU花在遍历目录上的时间便非同寻常,如果缓存文件的读写比较频繁的话,可能CPU使用率很容易到达100%,你可以使用支持目录hash等加速目录遍历的文件系统来缓解该情况,如XFS和reiserfs,可是如果你的站点已经在提供服务,则重新安装文件系统显得不太现实.  

幸运的是,我们可以通过**缓存目录分级**来解决这一问题,Smarty对它提供了支持,而对于其他框架而言,即便没有支持,修改程序使其按照你的旨意来分级存储,也不是一件困难的事情.这样一来,可以将每个目录下的子目录或文件的数量控制在少量范围内,同时适当增加目录切换次数,但这部分开销微不足道.  
#### 过期检查  
 到目前为止,我们给动态内容引入了缓存,它在一定程度上避免了动态内容不必要的重复计算,缩短了请求响应时间并提高了服务器吞吐率.但是,动态内容的目的在于提供变化的内容,所以它的缓存不可能长期有效,否则就失去了动态内容的意义,所以动态内容的缓存机制必须能判断必须能够判断缓存何时过期,以及何时需要生产新的缓存.  
 
为每个缓存标记过期时间,然后动态内容每次对缓存进行过期检查,这是一种常见的缓存过期检查策略.介绍两种过期检查方法:  
1. 每次检查时,根据**缓存的创建时间**,**缓存有效期**设置的长度,以及**当前时间**,来判断是否过期,也就是说,如果当前时间距离缓存创建时间间隔超过有效期长度的话,认为缓存过期,这是一种**相对比较**.  
2. 每次检查时,根据**缓存的过期时间**和**当前时间**来判断是否过期,这个方法比较简单,直接检查当前时间是否超过缓存期时间即可,这是一种**绝对比较**.  

在Smarty中,这两种方法对应的caching值分别为1和2.  

二者区别:  
**第一种**:修改缓存有效期长度会影响每一次的过期检查,这有利于对缓存过期时间的调试.  
**第二种**:在缓存期过期前,如果你修改了程序中的缓存有效期长度,是不会影响上一次缓存的过期时间.  
当然如果缓存有效期长度不会变化的话,这两种方法没有太大的区别.所以根据需要选择一种方法即可.  

Smarty的这种缓存过期检查方法存在一定的开销,因为每次请求动态内容时,即使是命中缓存,Smarty仍然要通过is_cached()和display()对缓存文件的内容进行两次分析,每次分析都调用了smarty_core_read_cache_file核心函数,包括提取缓存标志信息和HTML等,这涉及大量的字符串操作.如果将缓存过期标记和HTML单独存储,或许可以节省这部分字符串操作的时间.  
#### 把缓存放到内存  
 前面的两种缓存实现都将缓存数据存储在磁盘文件中,每次缓存加载和过期检查都存在磁盘I/O的开销,反过来它也受到磁盘负载的影响,如果这个磁盘同时还运行着如数据库这样的磁盘I/O密集型应用,那么缓存文件的I/O操作便会存在一定的延迟.  

我们还可以将动态网页的**HTML**缓存在其他地方,比如本机内存中,借助PHP的APC模块,我们可以轻松地将任何PHP运行时的数据或对象缓存在内存中,这样一来,加载缓存的过程中将没有任何磁盘I/O操作.APC数据缓存提供了Key/Value的存储方式,即使在保存大量Key的时候也能保证高效的查找性能,所以我们不用为了缓存目录分级的事情操心.同时,每个Key都可以设置有效期长度,一旦过期它便会被删除.  

不过这种方法带来的性能提升微不足道.虽然这次我们在内存中读写缓存,避免了之前文件缓存加载时的磁盘I/O开销,但是在动态网页处理的过程中,需要加载的磁盘文件非常多,而缓存文件只是其中的一个,仅仅把它放在内存里,对整体的影响当然微不足道.  

#### 缓存服务器  
 除此之外,我们还可以将HTML缓存存储在一台独立的缓存服务器中,利用memcached,我们可以很容易地通过TCP将缓存存储在其他服务器中,而且memcached同样也是使用内存空间来保存缓存数据,减少了不必要的磁盘I/O.另一方面,memcached在存储区中对于每一个key都维护一个过期时间,一旦到达这个过期时间,memcached便会自动删除这个key,这使得我们的过期检查非常容易,只需要在保存缓存数据时指定过期时间即可.但是它毕竟存在TCPsocket操作的开销,所以带来的性能提升效果一般,但是比Smarty内置缓存的方法好很多.  
![Alt text](./吞吐率对比.PNG)  
也许你一眼就看到了APC cache的性能优势,当然,这不是APC的特权,主要归咎于它使用了本地内存来存储缓存数据.但是,无论APC还是memcached,都使用内存来存储HTML缓存,以上我们的测试都只针对一个固定的动态网页,每次访问都处于缓存有效期内,所以缓存命中率是100%,而在实际情况中,一个站点包含了大量的动态网页,如果你为缓存分配的内存空间不足以容纳所有的缓存数据,便会使得缓存命中率大幅度下降,吞吐率也会随之降低.但是如果你希望为每个缓存保持较长的有效期,那么就要准备好足够的内存空间,可是如果购买更多的内存这就是一个经济问题,但是一旦本地内存达到上限,这似乎又变成了一个技术问题,往往到了这时候,你的站点规模已经让你不得不考虑比性能更加重要的问题,那就是如何扩展缓存存储区,显然,使用memcached来实现分布式缓存使得扩展成为可能.  

就速度而言,memcached不如使用本机内存的速度快,但是出于多方面的考虑,结合你的站点规模,也许你会觉得这很值得.首先,Web服务器特别是应用服务器本身的内存是相当宝贵的,它要满足HTTP进程和脚本解释器的大量开销,无法拿出大量的空间来存放HTML缓存;其次,使用本机内存不具备良好的扩展性,一旦缓存数据和站点负载大幅度增加,为了保存较高的缓存命中率,必须加大缓存空间,本机内存显然会成为瓶颈,而使用独立的缓存服务器可以便于扩展,构成多台服务器组成的**分布式缓存系统**.  

当然,对于小规模或者初创时期的Web站点,如果需要缓存的动态网页比较少,这时候使用APC内存缓存仍然不失为一个快速有效的方案,即便是规模膨胀后,快速重构缓存机制并且迁移缓存数据也不是一件多么复杂的事情.从APC过渡到memcached非常容易,往往我们无法预估未来,但是只要做好充分的准备就可以了.  
#### 有效期取值  
 **缓存有效期的取值**不是一件容易的事情.有效期如果太长,虽然缓存命中率提高了,但是动态网页的内容更新总是不能及时展现;而有效期如果太短,动态网页的内容虽能实时变化,但是频繁地创建缓存比没有缓存也好不到哪儿去.  

我们往往无法确定一个长期有效的取值,而事实上仅仅这个取值没有任何意义,更重要的是我们需要具备能够意识到有效期何时需要变化的能力,然后在任何时候找到当下最适合的取值.  

除了不断调整缓存有效期外,缓存机制还提供了一个有效的缓存控制途径,那就是可以在任何时候强行清除缓存,这在动态内容更新频率较低的时候适合使用.  
## 4.4 局部无缓存  
对于有些特殊的动态网页,需要页面中某一块区域的内容及时更新,如果为了这一块区域的及时更新,就将整个页面重新创建缓存的话,这确实有点不值得.在流行的模板框架中,在整个缓存的基础上,都提供了局部无缓存的支持,它允许在页面中指定一块包含动态数据的HTML代码段,每次这些动态数据都需要实时计算,然后和其余部分的缓存合成为最终的网页.  

引入局部无缓存机制后,动态网页控制器也要进行相应的修改,其目的就是把无缓存区域对应的动态数据计算提前到缓存检查之前,这样才可以保证每次都将实时计算后的结果输出到模板中.  
## 4.5 静态化内容  
 前面我们尝试的几种动态内容缓存方法中,动态程序看起来就像是缓存的代理人,每次用户的请求都有首先被送到动态程序,然后动态程序根据缓存有效期来决定是否输出缓存.这种方法使得动态内容对于缓存数据有着较强的控制权,但是这种控制权的代价是比较昂贵的,它带来了性能上的不足.  
 
#### 直接访问缓存  
 即:让用户直接请求HTML缓存.  
 它的吞吐率会比前面的动态内容缓存方法高出百倍,但是如此高的吞吐率的前提是:必须拥有很大的出口带宽.  

之前我们是在静态网页所在的服务器上执行测试,数据没有流出服务器,所以不存在出口带宽限制的问题.而在实际情况中,吞吐率往往受限于**Web服务器的出口带宽**.所以,要想让静态化页面达到或接近理论上的吞吐率,你可以购买更多的独享带宽(如1G带宽),然后为服务器安装千兆网卡,服务器所在网络也要适应千兆交换机,这样一来,静态化页面的性能才可以发挥到极限.  

尽管静态化网页的性能要大大高于动态缓存的可能性,但是我们要知道,静态化网页在请求的时候不涉及内容计算,这并不代表它不需要计算,它仍然需要由动态程序来创建和更新,我们不可能手动维护一个站点的所有动态页面,与之相比,动态内容缓存的一部分优越性便体现在这一点,通过封装良好的缓存管理机制,它成为名副其实的缓存代理人.  

然而,当我们一旦使用静态化网页的缓存方案后,你会发现原来的一切都被彻底颠覆.缓存更新,过期检查,以及缓存持久化等,都不能按照原来的方式来设计,我们必须重新来审视静态化缓存方案的具体实现.我们一般会使用CMS(内容管理系统)来管理静态化内容,同时CMS也可以在必要的时候帮助我们更新静态化内容.  

#### 更新策略  
对于静态化内容的更新策略,一般有以下两种:  
+ **在数据更新时重新生成静态化内容.**由用户的某些动作触发,这种方式在数据更新频繁时存在大量重建静态内容的开销,这将导致CMS系统的服务响应大幅度降低.另一方面,如果站点的静态化内容需要分发到更多的服务器,那么频繁的更新也会给文件的同步带来较大的压力.一个常见的办法是引入延迟更新机制,将更新任务放入队列,一旦队列写满或者到达超时时间,便一次性将它们更新到磁盘,这听起来有点像文件系统的磁盘缓冲区的设计动机,没错,你也可以把它理解为**静态化缓冲区**.  
+ **定时重新生成静态化内容.**一般通过定时任务来执行,比如crontab或者专用的daemon程序,然后通过CMS系统进行方便的管理,如果站点存在大量的静态化内容,而且它们的性质和实时性需求不尽相同,我们可以通过维护一定的对应关心来指定特定范围的静态化内容进行重建,从而节省开销.  

通常,这两种更新策略可以互相弥补,共同应用在站点的静态化方案中.如何选择并很好地使用它们,需要在重建性能和内容及时性需求之间取其平衡.  
#### 局部静态化  
 静态网页可以通过SSI(服务器端包含)技术实现各个页面的独立更新,这样便大大节省了重建整个网页时的计算开销和磁盘I/O开销,甚至包括分发时的网络I/O开销.  

一旦网页支持SSI,那么每次请求的时候服务器必须要通过读网页内容,查找include标签,这需要大量的CPU开销.**使用SSI时**,服务器加载子页面时执行系统调用open()和stat64()用于打开文件和查看文件状态所占时间比例较大.**不使用SSI时**,更多的时间会花在传输文件上.  

请求的文件越大,花在文件传输上的时间越多.单位时间的数据传输量也越大,同时花在处理socket连接以及打开文件等的时间比例越小.
