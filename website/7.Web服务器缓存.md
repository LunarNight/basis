# Web服务器缓存  
前面我们讨论过了动态内容缓存和静态化,基本上都是通过动态程序自身来实现缓存机制,包括缓存持久化,过期检查,缓存更新等.是否可以让Web服务器自己实现缓存机制呢?的确,Web服务器是应该站出来做点什么了······  

## 7.1 URL映射  
 对于任何Web服务器,当我们向它发送一个HTTP请求后,它要做的主要工作就是解析URL,然后完成**从URL到实际内容或资源的映射**.这里所说的映射是一个抽象的概念,实际上就是服务器处理请求并生成响应内容的过程,而这里之所以说"映射",是希望从URL的角度来看服务器的处理过程.  

在实际情况中,URL映射的过程中需要经历很多的环节,比如SSI模式下对于内容的通读.如果我们不看过程,只关注URL和最终的响应内容,则它们确实就像一系列的对应关系.  

## 7.2 缓存响应内容  
 我们可以将这些**对应关系缓存**起来.很多时候,一个URL在一段较长的时间内对应一个唯一的响应内容,比如静态内容或者更新不太频繁的动态内容,一旦将最终内容缓存后,下次Web服务器便可以在收到请求后立即拿出事先缓存好的响应内容并返回给浏览器,因为这个操作发生在所有其他行为之前,所以必然会节省一定的时间.  

幸运的是,将这份任务交给Web服务器来做是最适合不过的了,而且大多数情况下我们不需要亲自去实现它,主流的**Web服务器软件**都会提供类似的支持,比如Apache的mod_cache,它在URL映射开始时检查缓存,如果缓存存在并处于有效期,那么将直接取出作为响应内容返回给浏览器.  

#### 准备好缓存区  
 还有一点很重要,**将缓存内容存储在什么位置**,一般来说,**本机内存和磁盘**是主要选择.当然,也可以采用分布式设计,存储到其他服务器的内存或磁盘中,前面我们在介绍动态内容缓存时,便分别使用了磁盘,内存以及独立缓存服务器等方案.  

Apache提供的扩展mod_disk_cache为mod_cache提供存储引擎,使用磁盘文件系统来存储缓存.它在磁盘上维护了一块多个进程共享的缓存区,并且由于磁盘文件系统缓冲区以及MMAP的作用,磁盘缓存的访问速度甚至要超过mod_mem_cache实现的内存缓存.  

#### 缓存静态内容  
 对两个静态页面进行压力测试,使用了SSI的shtml页面的吞吐率比普通的html页面的吞吐率低.  

我们开启mod_disk_cache,再对它们进行同样条件下的压力测试,且在全缓存的情况下.结果:对于使用了SSI的shtml页面,Web服务器磁盘缓存起到了很大的性能提升,吞吐率提高了4倍之多,而对于普通的html页面,磁盘缓存的引入也有一定的性能提升,但是较为有限,吞吐率值提高了27%左右.  

#### 缓存动态内容  
 我们对动态程序进行压力测试,使用APC内存缓存以及APC opcode cache时候的结果是我们通过动态程序自身实现缓存机制的最好表现,其他使用磁盘和分布式缓存服务器的方案都要略逊于它.使用Web服务器缓存后(开启mod_disk_cache),再进行压力测试,它的吞吐率比之前高出近两倍.  

很难想象这是一个动态内容的测试结果,但从磁盘缓存的角度看,它实际上只是对静态文件的请求.  

另一个问题产生了,在引入了Web服务器磁盘缓存后,原本指向动态内容的请求可以迅速地获得缓存,但是它如何知道缓存是否过期以及如何控制缓存的有效期呢?  

#### 控制有效期  
 说到缓存过期的问题,你也许得花一点时间回顾一下前面介绍浏览器缓存时提到的缓存协商和过期时间等HTTP头信息中的标记,没错,这些标记(Expires,Last-Modified)再次派上了用场,Web服务器缓存对于动态内容的过期检查机制仍然是建立在HTTP/1.1协议上的对话,除此之外,它们之间没有其他的沟通方式,虽然它们在同一台物理机器上,但保持距离是非常必要的.  

#### 取而代之  
 这种Web服务器缓存机制是否可以取代动态程序自身的缓存机制呢?这也不失为一种方案,但你需要进行一些考虑.  

这样做会让动态程序依赖于特定的Web服务器,降低了应用的可移植性,但是,这也许对于你的站点来说无关紧要,你根本没有打算将其移植到其他平台,你只是希望快速建立一层透明的缓存机制,而且尽量少地修改动态程序代码,因为你对它们很厌烦.  

即便是需要移植到其他的Web服务器,由于我们采用的是基于HTTP的缓存机制,所以完全可以使用反向代理来快速对接,这在下一章中会有介绍,可以肯定的是,编写面向HTTP缓存友好的动态程序是非常必要的,它将拥有极强的生命力和适应性.  

有一点需要注意的是,这种缓存机制实质上是以URL为主键的key-value结构缓存,所以你必须保证所有希望缓存的动态内容都有唯一的URL.  

也许在有些时候,动态程序自身实现页面缓存(如Smarty内置缓存机制)显得有些多余,因为它们完全不用自己动手,而只需要打个招呼,说声Expires即可,在它们的前方,会有Web服务器缓存及浏览器缓存,还有随后即将介绍的反向代理缓存,帮它们来打理一切.  

## 7.3 缓存文件描述符  
 **文件描述符是反映系统资源的数据结构**,它也只能存在于本机内存中.  

对于静态内容,特别是拥有大量小文件的站点,Web服务器相当大的一部分开销花在了打开文件上,即open()系统调用,所以我们还可以考虑打开后的文件描述符直接缓存到Web服务器的内存中.  

Apache提供了相应的扩展mod_file_cache,它需要我们提供希望缓存文件描述符的文件列表,比如我们进行如下配置:CacheFile/data/www/htdocs/test.htm  

这样一来,Apache在启动的时候便会打开这些文件,并持续到Apache关闭为止,在这期间,如果有对这些文件的请求,Apache将通过文件描述符直接把文件传送出去.  

此方法会使得open()系统调用的时间占用比例明显减少,而主要时间花在了负责数据传送的writev()系统调用上.  

很显然,这种缓存文件描述符的缓存方案只适应于静态内容,与前面静态内容整体缓存到磁盘相比,这种方法可以减少打开文件的开销,而前者仍然需要从磁盘缓存区打开文件,但是,由于前者发生在URL映射的最前端,所以它完全弥补了由于打开文件的开销带来的性能损失,事实上前者的测试结果还要略高于缓存文件描述符时的吞吐率.  

缓存文件描述符对于较大的文件来说也许是不合适的,因为处理它们的主要时间花在传送数据上,而不是打开文件.  

另外,由于在Apache启动的时候就打开了大量的文件,并且需要在多个子进程中共享文件描述符,所以这必然带来了更多的内存开销,要说唯一节省的资源,那就是避免了磁盘缓存区的大量静态文件冗余,但是这不算什么.还有,当这些文件更新后,必须重启Apache才能生效.  
