现代计算机存储和处理的信息以二值信号表示.  
 我们研究三种最重要的数字表示:  
 1. **无符号**编码基于传统的二进制表示法,表示大于或者等于零的数字.  
 2. **补码**编码是表示有符号整数的最常见的方式,有符号整数就是可以为正或者为负的数字.  
 3. **浮点数**编码是表示实数的科学计数法的以二为基数的版本.  

## 2.1 信息存储  
 大多数计算机使用8位的块,或者字节(byte),作为最小的可寻址的存储器单位,而不是在存储器中访问单独的位.  
 机器级程序将存储器视为一个非常大的字节数组,称为**虚拟存储器**.存储器的每个字节都由唯一的一个数字来标识,称为它的地址,所有可能地址的集合称为**虚拟地址空间**.  

#### 2.1.1 十六进制表示法
 编写机器级程序的一个常见任务就是在位模式的十进制,二进制和十六进制表示之间人工进行转换.

#### 2.1.2 字  
每台计算机都有一个**字长**,指明整数和指针数据的标称大小.因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就会说虚拟地址空间的最大大小.  
今天大多数计算机的字长都是32位,这就限定了虚拟地址空间为4千兆字节(4GB).  

#### 2.1.3 数据大小  
 C语言中数字数据类型的字节数  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/DateType.png)  
 程序员应该力图使他们的程序在不同的机器和编译器上是可移植的.可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感.C语言标准对不同数据类型的数字范围设置了下届,但却没有设置上界.
 程序员假设一个声明为int类型的程序对象能被用来存储一个指针.这在大多数32位的机器上能正常工作,但是在一台64位的机器上却会导致问题.  
 
#### 2.1.4 寻址和字节顺序  
 对于跨越多字节的程序对象,我们必须建立两个规则:这个对象的地址是什么,以及在存储器中如何排列这些字节.  
 在几乎所有的机器上,多字节对象都被存储为连续的字节序列,对象的地址为所使用字节中最小的地址.  
 **小端法**:在存储器中按照从最低有效字节到最高有效字节的顺序存储对象.  
 **大端法**:在存储器中按照从最高有效字节到最低有效字节的顺序存储对象.  
 
 例:假设变量x类型为int,位于地址0x100处,它的十六进制值为0x01234567.地址范围为0x100~0x103的字节,其排列顺序依赖于机器的类型.  
 大端法:···0x100(01)0x101(23)0x102(45)0x103(67)···  
 小端法:···0x100(67)0x101(45)0x102(23)0x103(01)···  
 注意:在字0x01234567中,高位字节的十六进制值为0x01,而低位字节的十六进制值为0x67.  
 
 在不同类型的机器之间通过网络传送二进制数时,一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反向发送时会发现,接收程序里的字节成了反序的.为了避免类似问题,网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则,以确保发送方机器将它的内部表示转换成网络标准,而接收方机器则将网络标准转换为他的内部表示.  
 
 Linux32,Windows,Linux64是小端法机器,Sun是大端法机器.  
 不同的机器/操作系统配置使用不同的存储分配规则:  
 Linux32,Windows,Sun的机器使用4字节地址,Linux64使用8字节地址.  
 
#### 2.1.5 表示字符串
 C语言中字符串被编码为一个以null(值为0)字符结尾的字符数组.每个字符都由某个标准编码来表示,最常见的是ASCII字符码.因此,如果我们以参数"12345"和6(包括终止符)来运行例程show_bytes,我们得到结果31 32 33 34 35 00.请注意,十进制数字x的ASCII码正好是0x3x,而终止字节的十六进制表示为0x00.在使用ASCII码作为字符码的任何系统上将得到相同的结果,与字节顺序和子大小规则无关.因而文本数据比二进制数据具有更强的平台独立性.  
#### 2.1.6 表示代码
 不同的机器类型使用不同的且不兼容的指令和编码方式.即使是完全一样的进程运行在不同的操作系统上也会有不同的编码规则,一你猜二进制代码是不兼容的.二进制代码很少能在不同机器和操作系统组合之间移植. 计算机系统的一个基本概念就是从机器的角度看,程序仅仅是字节序列.  

#### 2.1.7 布尔代数简介
 二进制是计算机编码,存储和操作信息的核心.  
 布尔代数:通过将逻辑值TRUE和FALSE编码为二进制值1和0设计出的一种代数.  

#### 2.1.8 C语言中的位级运算
 C语言的一个很有用的特性就是它支持按位布尔运算.  
 以下是一些对char数据类型表达式求值的例子:  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/char.PNG)  
 确定一个位级表达式的结果最好的方法,就是将十六进制的参数扩展成二进制表示并执行二进制运算,然后再转换回十六进制.  
 位级运算的一个常见用法就是实现**掩码**运算,这里掩码是一个位模式,表示从一个字中选出位的集合.  

#### 2.1.9 C语言中的逻辑运算  
 逻辑运算符:||,&&,!   对应于OR,AND,NOT  
 逻辑运算很容易好位级运算向混淆,但它们的功能时完全不同的.逻辑运算认为所有非零的参数都表示true,而参数0表示false.它们返回1或者0,分别表示结果为true或者为false.  
 如果对第一个参数求职就能确定表达式的结果,那么逻辑运算符就不会对第二个参数求值.  
 
#### 2.1.10 C语言中的移位运算  
 逻辑左移与算数左移:低位补0  
 逻辑右移:高位补0  
 算数右移:高位补k个最高有效位的值  
 移位运算从左至右结合,x<<j<<k等价于(x<<j)<<k.  
 
 C语言标准并没有明确定义应该使用哪种类型的右移.  
 无符号数,右移必须是逻辑的;有符号数,算数的或者逻辑的都可以.  
 实际上,几乎所有的编译器/机器组合都对有符号数据使用算数右移,且许多程序员也都假设机器会使用这种右移.  
 Java对于右移有明确定义.x>>k会将x算数右移k个位置;而x>>>k会对x做逻辑右移.  
 C程序中,移位数量要保持小于字长(如:字长为4,移位数量要小于4*8=32)  
 Java中,移位数量按照求模方法计算(如:x>>36,在32位的机器上表示右移4位)   
 
 操作符优先级问题,表达式1<<2+3<<4,本意是(1<<2)+(3<<4),但在C语言中,表达式等价于1<<(2+3)<<4. 
 因为,加减法的优先级比移位运算要高.  
 
## 2.2 整数表示  

#### 2.2.1 整型数据类型  
 C语言支持多种**整型数据类型**——表示有限范围的整数.  
 32位机器上C语言的整型数据类型的典型取值范围(方括号中的文字是可选的)  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/int.PNG)  
 unsigned:指示被表示的数字是非负数  
 这些不同大小的分配的字节数会根据机器的字长和编译器有所不同.  
 这里给出的唯一一个与机器相关的取值范围是大小指示符long的.大多数64位机器使用8个字节表示,比32位机器上使用4个字节表示的取值范围大得多.  
 取值范围是不对称的——附属的范围比整数范围大1.  
 数据类型long long 至少需要8个字节表示.  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/int64.PNG)  
 C和C++都支持有符号数(默认)和无符号数.Java只支持有符号数.  
 
#### 2.2.2 无符号数的编码  
 无符号数:w位的无符号数所能表示的范围是0~2<sup>w</sup>-1  
 
#### 2.2.3 补码编码  
 最常见的有符号数的计算机表示方式就是补码形式.  
 将字的最高有效位解释为负权,最高有效位x<sub>w-1</sub>也称为**符号位**,它的"权重"为-2<sup>w-1</sup>,是无符号表示中权重的负数.  
 补码表示范围:-2<sup>w-1</sup>~2<sup>w-1</sup>-1 
 补码的范围是不对称的,这是因为一半的位模式(符号位设置为1的数)表示负数,而一半的数(符号位设置为0的数)表示非负数.因为0是非负数,也就是能表示的正数比负数少一个.  
 最大的无符号数值刚好比补码的最大值的两倍大一点:UMax<sub>w</sub>=2TMax<sub>w</sub>+1  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/ha.PNG)  
 C语言标准并没有要求用补码形式来表示有符号数,但几乎所有的机器都这么做的,许多程序的书写都假设用补码来表示有符号数,这样的程序在大量的机器和编译器上具有可移植性.  
 在Java中,单字节数据类型称为byte,而不是char,而且没有long long数据类型.  
 **反码**:除了最高有效位的权是-(2<sup>w-1</sup>-1)而不是-2<sup>w-1</sup>,它和补码是一样的.  
 **原码**:最高有效位是符号位,用来确定剩下的位应该取负权还是正权.  
 这两种表示方式,把[00···0]都解释为+0.而值-0在原码中表示为[10···0],在反码中表示为[11···1].  
 
#### 2.2.4 有符号数和无符号数之间的转换  
 对这个问题的回答都是从位级角度看的,而不是数的角度.  
 强制类型转换的结果保持位值不变,只是改变了解释这些位的方式.  
 如:有符号数-12345转换为无符号数是53191. -12345的16位补码表示与53191的16位无符号表示是完全一样的.  
 将short int强制类型转换为unsigned short改变数值,但是不改变位表示.  
 T2U<sub>16</sub>(-12345)=531919,U2T<sub>16</sub>(53191)=-12345  
 也就是说,十六进制表示写做0xCFC7的16位位模式既是-12345的补码表示,又是53191的无符号表示.  
 公式:T2U<sub>w</sub>(x)=x+2<sup>w</sup>,x<0  
      T2U<sub>w</sub>(x)=x,x>=0   
 极端:T2U<sub>w</sub>(-1)=-1+2<sup>w</sup>UMax<sub>w</sub>——最靠近0的负数映射为最大的无符号数.  
      T2U<sub>w</sub>(TMin<sub>w</sub>)=-2<sup>w-1</sup>+2<sup>w</sup>=2<sup>w-1</sup>=TMax<sub>w</sub>+1——最小的负数映射为一个刚好在补码的正数范围之外的无符号数.  
      
#### 2.2.5 C语言中的有符号数与无符号数  
 通常大多数数字被默认为是有符号的.要创建一个无符号常量,必须加上后缀字符"U"或者"u".例如12345U  
 用printf输出数值时,分别用指示符%d,%u和%x以有符号十进制,无符号十进制和十六进制格式输出一个数字.  
 在C语言中,当执行一个运算时,如果它的一个运算数是有符号的而另一个是无符号的,那么C语言会隐式地将有符号参数强制类型转换为无符号数,并假设这两个数都是非负的,来执行这个运算.  
 这种方法对于标准的算数运算来说并无多大差异,但是对于像<和>这样的关系运算符来说,它会导致非至关的结果.  
 例:比较表达式 -1<0U.因为第二个运算符是无符号的,第一个运算数就会被隐式地转换为无符号数,因此表达式就等价于4294967295U<0U 这个答案显然是错的.  
 
#### 2.2.6 扩展一个数字的位表示  
 将一个无符号数转换为一个更大的数据类型,我们只需简单地在表示的开头添加0,这种运算称为**零扩展**.  
 将一个补码数字转换为一个更大的数据类型可以执行**符号扩展**,规则是在表示中添加最高有效位的值的副本.  
 [101]表示值-4+1=-3  对应符号扩展[1101]也表示值-8+4+1=-3  
 从一个数据大小到另一个数据大小的转换,以及无符号数和有符号数字之间的转换的相对顺序能够影响一个程序的行为.  
 ```
 short sx = -12345; // -12345  
 unsigned uy = sx;  // 4294954951  
 // 先对sx改变大小,再完成从有符号数到无符号数的转换.  
 //即unsigned sx 等价于 (unsigned)(int)sx,得到4294954951.  
 //而不是(unsigned)(unsigned short)sx.求得53191.  
 ```  
 
 这个规则是c语言标准要求的.  
 
#### 2.2.7 截断数字  
 如果我们不用额外的位来扩展一个数值,而是减少表示一个数字的位数.  
 ```  
 int x=53191;  
 short sx=(short)x;  /*-12345*/  
 int y=sx;  /*-12345*/  
 ```  
 对于一个无符号数字x,截断它到k位的结果就相当于计算xmod2<sup>k</sup>  
 对于一个补码数字x,我们通常将被截断的数字视为有符号的.这将得到数值U2T<sup>k</sup>(xmod2<sup>k</sup>)  
 
####2.2.8 关于有符号数与无符号数的建议  
 有符号数到无符号数的隐式转换,会导致错误或者漏洞的方式.避免这一错误的一种方法就是绝不使用无符号数.  
 当实现模运算和多精度运算的数学包时,数字是由字的数组来表示的,无符号值也会非常有用.  
 
## 2.3 整数运算  
 有时,两个正数相加会得出一个负数,并且比较表达式x<y和比较表达式x-y<0会产生不同的结果.这些属性是由于计算机运算的有限性造成的.  
 
#### 2.3.1 无符号加法  
 无符号运算可以被视为一种模运算形式,无符号加法等价于计算和模上2<sup>w</sup>.可以通过简单的丢弃x+y的w+1位表示的最高位,来计算这个数值.  
 0<=x,y<2<sup>w</sup>,则(1)x+y=x+y,x+y<2<sup>w</sup>     (2)x+y=x+y-2<sup>w</sup>,2<sup>w</sup><=x+y<=2<sup>w+1</sup>  
 一个算数结果的**溢出**,是指完整的整数结果不能放到数据类型的字长限制中去,如上述第二种运算情况
 在C程序中判定是否发生了溢出:如S=x+y,当且仅当s<x(或s<y)时,就发生了溢出.即溢出的结果比两个数都小.  
 
#### 2.3.2 补码加法  
 两个数的w位补码之和与无符号之和有完全相同的位级表示.实际上,大多数计算机使用同样的机器指令来执行无符号或者有符号加法.  
 我们将表示截断到w位,来避免数据大小的不断扩张.
 例:-2<sup>w-1</sup><=x,y<=2<sup>w-1</sup>-1  
 和为:x+y-2<sup>w</sup>[2<sup>w-1</sup><=x+y]正溢出  
     x+y[-2<sup>w-1</sup><=x+y<2<sup>w-1</sup>]正常  
     x+y+2<sup>w</sup>[x+y<-2<sup>w-1</sup>]负溢出  
#### 2.3.3 补码的非  
 -2<sup>w-1</sup><=x<2<sup>w-1</sup>  
 当x=-2<sup>w-1</sup>时,结果为:-2<sup>w-1</sup>  
 当x>-2<sup>w-1</sup>,结果为:-x  
 计算一个位级表示的值的补码非:对每一位求补,再对结果加1.  
 
#### 2.3.4 无符号乘法  
 0<=x,y<=2<sup>w</sup>-1  
 x*<sup>u</sup><sub>w</sub>y=(x·y)mod2<sup>w</sup>  
 
#### 2.3.5 补码乘法  
 如下表,我们给出了不同3位数字的乘法结果.对于每一对位级运算数,我们执行无符号和补码乘法,得到6位的乘积,然后截断到3位.  
 无符号的截断后的乘积总是等于x·ymod8. 虽然无符号和补码两种乘法乘积的6位表示不同,但是截断后的乘积的位级表示都相同,即低位是相同的.  
#### 2.3.6 乘以常数  
 编译器使用了一项重要的优化,试着用移位和加法运算的组合来替代乘以常数因子的乘法.  
 x<<k等价于x*pwr2k,这里pwr2k等于2<sup>w</sup>  
 例:x*14,利用等式14=2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>,编译器会将乘法重写为(x<<3)+(x<<2)+(x<<1),实现了将一个乘法替换为三个移位和两个加法.无论x是无符号的还是补码,即使当乘法会导致溢出时,两个计算都会得到一样的结果.  
 编译器还可以利用14=2<sup>4</sup>-2<sup>1</sup>,将乘法重写为(x<<4)-(x<<1).只需两个移位和一个减法.  
 
#### 2.3.7 除以2的幂  
 在大多数机器上,整数除法要比整数乘法慢.除以2的幂我们可以用右移来实现.  
 无符号和补码数分别使用逻辑移位和算数移位来达到目的.  
 无符号数:移位总是舍入到0,[12340>>4]=[771.25]=771  
 补码数:对于一个正整数,最高有效位是0,所以效果与逻辑右移一样.因此,对于非负数,算数右移k位与除以2<sup>k</sup>是一样的.  
 作为一个负数的例子,对于一个不需要舍入的情况结果是正确的.但是当需要进行舍入是,移位导致结果向下舍入,而不是像规则需要的那样向零舍入.例如:-12340/2<sup>2</sup>=-771.25.应该得到-771而不是-772.为了修正这种不合适的舍入,我们可以在移位之前**偏置**这个值.  
 
 对于整数x和任意y>0的y,有[[x/y]=[(x+y-1)/y].即:通过给x增加一个偏量y-1,然后再将除法向下舍入,当y整除x时,我们得到k,否则就得到k+1.因此,对于x<0,如果在右移之前,先将x加上2<sup>k</sup>-1,那么我们就会得到正确舍入的结果了.  
 
 除以2的幂可以通过逻辑或算数右移实现,但这种方法不能推广到除以任意常数.  
 同乘法不同,我们不能用除以2的幂的除法来表示除以任意常数K的除法.  
 
## 2.4 浮点数  
 浮点表示对形如V=x*2<sup>y</sup>的有理数进行编码.它对执行涉及非常大的数字(|V|>>0)、非常接近于0(|V|<<1)的数字,以及更普遍地作为实数运算的近似值的计算,是很有用的.  
 IEEE标准:表示浮点数及其运算的标准.  
#### 2.4.1 二进制小数  
 小数点左边的数字的权是2的正次幂,小数点右边的数字的权是2的负次幂.  
 假设我们进考虑优先长度的编码,那么小数的二进制表示法只能表示那些能够被写成x*2<sup>y</sup>的数,其他的值只能够被近似地表示.  
 浮点运算的不精确性能够产生灾难性的后果.  
 
#### 2.4.2 IEEE浮点表示  
IEEE浮点标准用V=(-1)<SUP>S</SUP>*M*2<sup>E</sup>的形式来表示一个数:  
 **符号**(sign):s决定这数是负数(s=1)还是正数(s=0),而对于数值0的符号位解释作为特殊情况处理.  
 **尾数**(significand):M是一个二进制小数,它的范围是1~2-ε,或者是0~1-ε.  
 **阶码**(exponent):E的作用是对浮点数加权,这个权重是2的E次幂(可能是负数).  
 将浮点数的位表示划分为三个字段,分别对这些值进行编码:  
 一个单独的符号位s直接编码符号s  
 k位的阶码字段exp=e<sub>k-1</sub>···e<sub>1</sub>e<sub>0</sub>编码阶码E  
 n位小数字段frac=f<sub>n-1</sub>···f<sub>1</sub>f<sub>0</sub>编码尾数M,但是编码出来的值也依赖于阶码字段的值是否等于0.  
 
 在单精度浮点格式(C语言中的float)中,s,exp和frac字段分别为1位,k=8位和n=23位,得到一个32 位的表示.  
 在双精度浮点格式(C语言中的double)中,s,exp,frac字段分别为1位,k=11位和n=52位,得到一个64位的表示.  
 给定位表示,根据exp的值,被编码的值可以分成三种不同的情况:  
 **情况1：规格化的值**  
  当exp的位模式既不全为0,也不全为1(单精度数值为255,双精度数值为2047)时,都属于这类情况.在这种情况中,阶码字段被解释为以**偏置(biased)**形式表示的有符号整数.也就是说,阶码的值是E = e - Bias,其中e是无符号数,其位表示为e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>,而Bias是一个等于2<sup>k-1</sup>-1(单精度是127,双精度是1023)的偏置值.由此产生指数的取值范围,对于单精度是-126~+127,而对于双精度是1022~+1023.  
  对小数字段frac的解释为描述小数值f,其中0\<=f\<1,其二进制表示为0.f<sub>n-1</sub>...f<sub>1</sub>f<sub>0</sub>,也就是二进制小数点在最高有效位的左边.位数定义为M = 1 + f.有时这种方式也叫做隐含的以1开头的表示,可以把M堪称一个二进制表达式为1.f<sub>n-1</sub>...f<sub>1</sub>f<sub>0</sub>的数字.总能够调整阶码E,使得位数M在范围1\<=M\<2之中(假设没有溢出),由于第一位总是等于1,因此就不需要显式地表示它.  
  **情况2：非规格化的值**
 当阶码域为全0时,锁表示的数就是**非规格化**形式.在这种情况下,阶码值是 E = 1 - Bias.而位数的值是 M = f.也就是小数字段的值,不包含隐含的开头1.  
 非规格化数有两个用途,首先可以表示数值0.因为使用规格化数,必须总是使M\>=1,因此不能表示0.实际上,+0.0的浮点表示的位模式全为0;符号是0,阶码字段全为0(表明是一个非规格化值),而小数域也全为0,这就得到M = f = 0.当符号位为1,其他全为0,得到值-0.0.  
 非规格化数的另一个功能是表示非常接近于0.0的数,它们提供了一种属性,称为**逐渐溢出**,其中可能的数值分布均匀地接近于0.0.  
 **情况3：特殊值**
 当指阶码全为1,当小数域全为0,得到的值表示无穷.当s = 0是 正无穷,s = 1时是负无穷.当把两个非常大数相乘,或除以零时,无穷能够表示**溢出**的结果.当小数域为非零时,结果值被称为"NAN",一些运算的结果不能是实数或无穷,比如计算 根号-1.  
#### 2.4.3 数字实例  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/float.PNG)  
 
#### 2.4.4舍入
 因为表示方法限制了浮点数的范围和经度,浮点运算只能近似地表示实数运算.  
 分为向偶数舍入,向零舍入,向下舍入,向上舍入.  
 向偶数舍入法能够运用于二进制小数.我们将最低有效位的值0认为是偶数,值1认为是奇数.  
 10.10100<sub>2</sub>向下舍入成10.10<sub>2</sub>,将10.11100<sub>2</sub>向上舍入成11.00<sub>2</sub>.因为这些值是两个可能值的中间值,倾向于使最低有效位为零.  
 
#### 2.4.5浮点运算
 诸如加法和乘法这样的算数运算的结果,把浮点值x和y看成实数,而某个运算⊙,计算将产生Round(x⊙y).对实际运算的精确结果进行舍入后的结果.      
 浮点数操作不可结合.表达式(3.14+1e10)-1e10求值得到0.0 因为舍入,3.14会丢失.另一方面表达式3.14+(1e10-1e10)得到值3.14.  
 
## 2.5 小结
 计算机将信息按位编码,通常组织成字节序列.用不同的编码方式表示整数,实数和字符串.不同的计算机模型在编码数字和多字节数据中的字节排序时使用不同的约定.  
 大多数机器对整数使用补码编码,而对浮点数使用IEEE浮点编码.需要理解这些编码,对于想使编写的程序能在全部数值范围上正确运算是很重要的.      
 在相同长度的无符号和有符号整数之间进行强制类型转换,C语言实现遵循的原则是 底层的位模式不变.改变读取模式.  
 由于编码的长度有限,与传统整数和实数运算相比,计算机运算具有完全不同的属性.当超出表示范围时,有限长度能够引起数值溢出.当浮点数非常接近于0.0,从而转换成0时,也会下溢.  
 必须小心地使用浮点运算,因为浮点运算只有有限的范围和经度,而且不遵守普遍的算数属性,比如结合性.  
 
 
 
 
 
