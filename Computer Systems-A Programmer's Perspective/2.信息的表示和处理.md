现代计算机存储和处理的信息以二值信号表示.  
 我们研究三种最重要的数字表示:  
 1. **无符号**编码基于传统的二进制表示法,表示大于或者等于零的数字.  
 2. **补码**编码是表示有符号整数的最常见的方式,有符号整数就是可以为正或者为负的数字.  
 3. **浮点数**编码是表示实数的科学计数法的以二为基数的版本.  

## 2.1 信息存储  
 大多数计算机使用8位的块,或者字节(byte),作为最小的可寻址的存储器单位,而不是在存储器中访问单独的位.  
 机器级程序将存储器视为一个非常大的字节数组,称为**虚拟存储器**.存储器的每个字节都由唯一的一个数字来标识,称为它的地址,所有可能地址的集合称为**虚拟地址空间**.  

#### 2.1.1 十六进制表示法
 编写机器级程序的一个常见任务就是在位模式的十进制,二进制和十六进制表示之间人工进行转换.

#### 2.1.2 字  
每台计算机都有一个**字长**,指明整数和指针数据的标称大小.因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就会说虚拟地址空间的最大大小.  
今天大多数计算机的字长都是32位,这就限定了虚拟地址空间为4千兆字节(4GB).  

#### 2.1.3 数据大小  
 C语言中数字数据类型的字节数  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/DateType.png)  
 程序员应该力图使他们的程序在不同的机器和编译器上是可移植的.可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感.C语言标准对不同数据类型的数字范围设置了下届,但却没有设置上界.
 程序员假设一个声明为int类型的程序对象能被用来存储一个指针.这在大多数32位的机器上能正常工作,但是在一台64位的机器上却会导致问题.  
 
#### 2.1.4 寻址和字节顺序  
 对于跨越多字节的程序对象,我们必须建立两个规则:这个对象的地址是什么,以及在存储器中如何排列这些字节.  
 在几乎所有的机器上,多字节对象都被存储为连续的字节序列,对象的地址为所使用字节中最小的地址.  
 **小端法**:在存储器中按照从最低有效字节到最高有效字节的顺序存储对象.  
 **大端法**:在存储器中按照从最高有效字节到最低有效字节的顺序存储对象.  
 
 例:假设变量x类型为int,位于地址0x100处,它的十六进制值为0x01234567.地址范围为0x100~0x103的字节,其排列顺序依赖于机器的类型.  
 大端法:···0x100(01)0x101(23)0x102(45)0x103(67)···  
 小端法:···0x100(67)0x101(45)0x102(23)0x103(01)···  
 注意:在字0x01234567中,高位字节的十六进制值为0x01,而低位字节的十六进制值为0x67.  
 
 在不同类型的机器之间通过网络传送二进制数时,一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反向发送时会发现,接收程序里的字节成了反序的.为了避免类似问题,网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则,以确保发送方机器将它的内部表示转换成网络标准,而接收方机器则将网络标准转换为他的内部表示.  
 
 Linux32,Windows,Linux64是小端法机器,Sun是大端法机器.  
 不同的机器/操作系统配置使用不同的存储分配规则:  
 Linux32,Windows,Sun的机器使用4字节地址,Linux64使用8字节地址.  
 
#### 2.1.5 表示字符串
 C语言中字符串被编码为一个以null(值为0)字符结尾的字符数组.每个字符都由某个标准编码来表示,最常见的是ASCII字符码.因此,如果我们以参数"12345"和6(包括终止符)来运行例程show_bytes,我们得到结果31 32 33 34 35 00.请注意,十进制数字x的ASCII码正好是0x3x,而终止字节的十六进制表示为0x00.在使用ASCII码作为字符码的任何系统上将得到相同的结果,与字节顺序和子大小规则无关.因而文本数据比二进制数据具有更强的平台独立性.  
#### 2.1.6 表示代码
 不同的机器类型使用不同的且不兼容的指令和编码方式.即使是完全一样的进程运行在不同的操作系统上也会有不同的编码规则,一你猜二进制代码是不兼容的.二进制代码很少能在不同机器和操作系统组合之间移植. 计算机系统的一个基本概念就是从机器的角度看,程序仅仅是字节序列.  

#### 2.1.7 布尔代数简介
 二进制是计算机编码,存储和操作信息的核心.  
 布尔代数:通过将逻辑值TRUE和FALSE编码为二进制值1和0设计出的一种代数.  

#### 2.1.8 C语言中的位级运算
 C语言的一个很有用的特性就是它支持按位布尔运算.  
 以下是一些对char数据类型表达式求值的例子:  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/char.PNG)  
 确定一个位级表达式的结果最好的方法,就是将十六进制的参数扩展成二进制表示并执行二进制运算,然后再转换回十六进制.  
 位级运算的一个常见用法就是实现**掩码**运算,这里掩码是一个位模式,表示从一个字中选出位的集合.  

#### 2.1.9 C语言中的逻辑运算  
 逻辑运算符:||,&&,!   对应于OR,AND,NOT  
 逻辑运算很容易好位级运算向混淆,但它们的功能时完全不同的.逻辑运算认为所有非零的参数都表示true,而参数0表示false.它们返回1或者0,分别表示结果为true或者为false.  
 如果对第一个参数求职就能确定表达式的结果,那么逻辑运算符就不会对第二个参数求值.  
 
#### 2.1.10 C语言中的移位运算  
 逻辑左移与算数左移:低位补0  
 逻辑右移:高位补0  
 算数右移:高位补k个最高有效位的值  
 移位运算从左至右结合,x<<j<<k等价于(x<<j)<<k.  
 
 C语言标准并没有明确定义应该使用哪种类型的右移.  
 无符号数,右移必须是逻辑的;有符号数,算数的或者逻辑的都可以.  
 实际上,几乎所有的编译器/机器组合都对有符号数据使用算数右移,且许多程序员也都假设机器会使用这种右移.  
 Java对于右移有明确定义.x>>k会将x算数右移k个位置;而x>>>k会对x做逻辑右移.  
 C程序中,移位数量要保持小于字长(如:字长为4,移位数量要小于4*8=32)  
 Java中,移位数量按照求模方法计算(如:x>>36,在32位的机器上表示右移4位)   
 
 操作符优先级问题,表达式1<<2+3<<4,本意是(1<<2)+(3<<4),但在C语言中,表达式等价于1<<(2+3)<<4. 
 因为,加减法的优先级比移位运算要高.  
 
## 2.2 整数表示  

#### 2.2.1 整型数据类型  
 C语言支持多种**整型数据类型**——表示有限范围的整数.  
 32位机器上C语言的整型数据类型的典型取值范围(方括号中的文字是可选的)  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/int.PNG)  
 unsigned:指示被表示的数字是非负数  
 这些不同大小的分配的字节数会根据机器的字长和编译器有所不同.  
 这里给出的唯一一个与机器相关的取值范围是大小指示符long的.大多数64位机器使用8个字节表示,比32位机器上使用4个字节表示的取值范围大得多.  
 取值范围是不对称的——附属的范围比整数范围大1.  
 数据类型long long 至少需要8个字节表示.  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/int64.PNG)  
 C和C++都支持有符号数(默认)和无符号数.Java只支持有符号数.  
 
#### 2.2.2 无符号数的编码  
 无符号数:w位的无符号数所能表示的范围是0~2<sup>w</sup>-1  
 
#### 2.2.3 补码编码  
 最常见的有符号数的计算机表示方式就是补码形式.  
 将字的最高有效位解释为负权,最高有效位x<sub>w-1</sub>也称为**符号位**,它的"权重"为-2<sup>w-1</sup>,是无符号表示中权重的负数.  
 补码表示范围:-2<sup>w-1</sup>~2<sup>w-1</sup>-1 
 补码的范围是不对称的,这是因为一半的位模式(符号位设置为1的数)表示负数,而一半的数(符号位设置为0的数)表示非负数.因为0是非负数,也就是能表示的正数比负数少一个.  
 最大的无符号数值刚好比补码的最大值的两倍大一点:UMax<sub>w</sub>=2TMax<sub>w</sub>+1  
 ![image](https://github.com/LovingStar/basis/blob/master/Computer%20Systems-A%20Programmer's%20Perspective/IMAGE/ha.PNG)  
 C语言标准并没有要求用补码形式来表示有符号数,但几乎所有的机器都这么做的,许多程序的书写都假设用补码来表示有符号数,这样的程序在大量的机器和编译器上具有可移植性.  
 在Java中,单字节数据类型称为byte,而不是char,而且没有long long数据类型.  
 **反码**:除了最高有效位的权是-(2<sup>w-1</sup>-1)而不是-2<sup>w-1</sup>,它和补码是一样的.  
 **原码**:最高有效位是符号位,用来确定剩下的位应该取负权还是正权.  
 这两种表示方式,把[00···0]都解释为+0.而值-0在原码中表示为[10···0],在反码中表示为[11···1].  
 
#### 2.2.4 有符号数和无符号数之间的转换  
 对这个问题的回答都是从位级角度看的,而不是数的角度.  
 强制类型转换的结果保持位值不变,只是改变了解释这些位的方式.  
 如:有符号数-12345转换为无符号数是53191. -12345的16位补码表示与53191的16位无符号表示是完全一样的.  
 将short int强制类型转换为unsigned short改变数值,但是不改变位表示.  
 T2U<sub>16</sub>(-12345)=531919,U2T<sub>16</sub>(53191)=-12345  
 也就是说,十六进制表示写做0xCFC7的16位位模式既是-12345的补码表示,又是53191的无符号表示.  
 公式:T2U<sub>w</sub>(x)=x+2<sup>w</sup>,x<0  
      T2U<sub>w</sub>(x)=x,x>=0   
 极端:T2U<sub>w</sub>(-1)=-1+2<sup>w</sup>UMax<sub>w</sub>——最靠近0的负数映射为最大的无符号数.  
      T2U<sub>w</sub>(TMin<sub>w</sub>)=-2<sup>w-1</sup>+2<sup>w</sup>=2<sup>w-1</sup>=TMax<sub>w</sub>+1——最小的负数映射为一个刚好在补码的正数范围之外的无符号数.  
      
#### 2.2.5 C语言中的有符号数与无符号数  
 通常大多数数字被默认为是有符号的.要创建一个无符号常量,必须加上后缀字符"U"或者"u".例如12345U  
 用printf输出数值时,分别用指示符%d,%u和%x以有符号十进制,无符号十进制和十六进制格式输出一个数字.  
 在C语言中,当执行一个运算时,如果它的一个运算数是有符号的而另一个是无符号的,那么C语言会隐式地将有符号参数强制类型转换为无符号数,并假设这两个数都是非负的,来执行这个运算.  
 这种方法对于标准的算数运算来说并无多大差异,但是对于像<和>这样的关系运算符来说,它会导致非至关的结果.  
 例:比较表达式 -1<0U.因为第二个运算符是无符号的,第一个运算数就会被隐式地转换为无符号数,因此表达式就等价于4294967295U<0U 这个答案显然是错的.  
 
#### 2.2.6 扩展一个数字的位表示  
 将一个无符号数转换为一个更大的数据类型,我们只需简单地在表示的开头添加0,这种运算称为**零扩展**.  
 将一个补码数字转换为一个更大的数据类型可以执行**符号扩展**,规则是在表示中添加最高有效位的值的副本.  
 [101]表示值-4+1=-3  对应符号扩展[1101]也表示值-8+4+1=-3  
 从一个数据大小到另一个数据大小的转换,以及无符号数和有符号数字之间的转换的相对顺序能够影响一个程序的行为.  
 ```
 short sx = -12345; // -12345  
 unsigned uy = sx;  // 4294954951  
 // 先对sx改变大小,再完成从有符号数到无符号数的转换.  
 //即unsigned sx 等价于 (unsigned)(int)sx,得到4294954951.  
 //而不是(unsigned)(unsigned short)sx.求得53191.  
 ```  
 
 这个规则是c语言标准要求的.  
 
#### 2.2.7 截断数字  
 如果我们不用额外的位来扩展一个数值,而是减少表示一个数字的位数.  
 ```  
 int x=53191;  
 short sx=(short)x;  /*-12345*/  
 int y=sx;  /*-12345*/  
 ```  
 对于一个无符号数字x,截断它到k位的结果就相当于计算xmod2<sup>k</sup>  
 对于一个补码数字x,我们通常将被截断的数字视为有符号的.这将得到数值U2T<sup>k</sup>(xmod2<sup>k</sup>)  
 
####2.2.8 关于有符号数与无符号数的建议  
 有符号数到无符号数的隐式转换,会导致错误或者漏洞的方式.避免这一错误的一种方法就是绝不使用无符号数.  
 当实现模运算和多精度运算的数学包时,数字是由字的数组来表示的,无符号值也会非常有用.  
 
## 2.3 整数运算
 
 
 
