
 1. 在编程语言中,能够表示并操作的值的类型称做**数据类型**,编程语言最基本的特性就是能够支持多种数据类型.  
 JavaScript的数据类型分为两类:原始类型和对象类型.  
 **原始类型**:数字,字符串,布尔值,null(空),undefined(未定义)  
 **对象类型**:普通的JavaScript对象是"命名值"的无序集合;**数组**,表示带编号的值的有序集合;**函数**,是具有与它相关联的可执行代码的对象.  
 JavaScript为数组和函数都定义了专用语法.  
 2. 如果函数用来初始化(使用new运算符)一个新建的对象,我们称之为**构造函数**.每个构造函数定义了一类(class)对象——由构造函数初始化的对象组成的集合.**类**可以看做是对象类型的子类型.  
 数组类(Array),函数类(Function),日期类(Date),正则类(RegExp),错误类(Error).  
 3. JavaScript解释器都有自己的内存管理机制,可以自动对内存进行来及回收.  
 4. JavaScript是一种面向对象的语言.不严格地来讲,这意味着我们不用全局的定义函数去操作不同类型的值,数据类型本身可以定义方法来使用值.  
 `  
 a.sort();  //sort(a)的面向对象版本  
 `  
 5. 从技术上讲,只有JavaScript对象才能拥有方法.然而,数字,字符串,布尔值也可以拥有自己的方法;JavaScript中只有null和undefined是无法拥有方法的值.  
 6. JavaScript的类型分法:原始类型和对象类型;可以拥有方法类型和不能拥有方法类型;可变类型和不可变类型.  
 可变类型:对象和数组;不可变类型:数字,布尔值,null,undefined,字符串.  
 7. JavaScript可以自由地进行数据类型转换.JavaScript变量无类型的,变量可以被赋予任何类型的值,同样一个变量也可以重新赋予不同类型的值,使用var关键字来声明变量.  
 8. JavaScript采用词法作用域.不在任何函数内声明的变量称做**全局变量**,它在JavaScript中的任何地方都是可见的.在函数内声明的变量具有函数作用域,并且只在函数内可见.  
 
## 3.1 数字   
 和其他编程语言不同,JavaScript不区分整数值和浮点数值.JavaScript中的所有数字均用浮点数值表示.JavaScript采用IEEE754标准定义的64位浮点格式表示数字.  
 当一个数字直接出现在JavaScript程序中,我们称之为**数字直接量**.  
 
#### 3.1.1 整型直接量   
 JavaScript支持十进制和十六进制的整型直接量,在ECMAScript6的严格模式下,八进制直接量是明令禁止的.  
#### 3.1.2 浮点型直接量   
 两种写法:**实数写法**;**指数记数法**,1.4738223E-32  //1.4738223 x 10<sup>-32</sup>   
#### 3.1.3 JavaScript中的算数运算   
 JavaScript中的算数运算在以下三种情况下不会报错:  
 
 1. 溢出(overflow):Infinity/-Infinity  
 2. 下溢(underflow):零/负零  
 3. 被零整除:Infinity/-Infinity 零除以零NaN表示(无穷大除以无穷大等无法转换为数字的操作数一起使用时都将返回NaN)  
 
**Infinity和NaN均为JavaScript预定义的全局变量**  
 JavaScript中的非数字值和任何值都不相等,包括自身.  
 负零值和正零值严格相等(===)  
#### 3.1.4 二进制浮点数和四舍五入错误   
JavaScript 采用的IEEE754标准是一种二进制表示法,能够精确地表示二进制分数却不能够精确地表示十进制分数.  
#### 3.1.5 日期和时间   
日期对象的方法为日期计算提供了简单的API.  

## 3.2 文本   
 **字符串**是一组由16位值组成的不可变得有序序列,每个字符通常来自于Unicode字符集.  
 JavaScript采用UTF-16编码的Unicode字符集.  
#### 3.2.1 字符串直接量   
 **字符串直接量**是由单引号或双引号括起来的字符序列,单引号里可以包含双引号,反之亦可.  
 字符串直接量可以用反斜线(\)拆分成数行.输出显示为一行.  
 转义字符\n可以在字符串直接量中另起一行.输出显示为数行.  
 当JavaScript代码和HTML代码混杂时,前者用单引号,后者用双引号.  
#### 3.2.2 转义字符   
 转义字符:反斜线(\)  
 需要在一个单引号定界的字符串内使用撇号的时候:  
 `  
 'You\'re right,it can\'t be a quote'  
 `  
#### 3.2.3 字符串的使用   
 JavaScript的内置功能之一:字符串连接,用加号(+).  
#### 3.2.4 模式匹配   
 RegExp并不是语言中的基本类型,但是他们依然具有直接量写法,可以直接在JavaScript程序中使用.在两条斜线之间的文本构成了一个正则表达式直接量.   
## 3.3 布尔值  
 布尔值通常用于JavaScript中的控制结构中.  
 任意JavaScript的值都可以转换为布尔值.  
 下面这些值会被转换成false:undefined,null,0,-0,NaN,""  
 所有其它值,包括所有对象(数组)都会转换成true  
 false和上面6个可以转换成false的值有时称做"假值",其它值称做"真值".  
 
## 3.4 null和Undefined   
 null是JavaScript语言的关键字,描述"空值"  
 undefined是预定义的全局变量,它不是关键字,值是"未定义"  
 如果想将他们赋值给变量或者属性,或将他们作为参数传入函数,最佳选择是使用null.  
## 3.5 全局对象   
 当JavaScript解释器启动时(或者任何web浏览器加载新页面时),它将创建一个新的全局对象,并给它一组定义的初始属性:  
 
 + 全局属性,比如:undefined,Infinity和NaN  
 + 全局函数,比如:isNaN(),parseInt(),和eval()  
 + 构造函数,比如:Date(),RegExp(),String(),Object(),Array()  
 + 全局对象,比如:Math和JSON  
 
## 3.6 包装对象  
 存储字符串,数字或布尔值的属性时创建的临时对象称做包装对象,它只是偶尔用来区分字符串值和字符串对象,数字和数值对象以及布尔值和布尔对象.由于字符串,数字和布尔值的属性都是只读的,并且不能给他们定义新属性,因此它们有别于对象.  
 ```  
 var s="test",n=1,b=true;  
 var S=new String(s);  
 var N=new Number(n);  
 var B=new Boolean(b);   
 ```
 
## 3.7 不可变的原始值和可变的对象引用  
 **原始值的比较**是值的比较:只有在它们的值相等时它们才相等.  
 如果比较两个单独的字符串,当且仅当它们的长度相等且每个索引的字符都相等时,JavaScript才认为它们相等.  
 **对象的比较**并非值的比较:即使两个对象包含同样的属性及相同的值,它们也是不相等的.各个索引元素完全相等的两个数组也不相等.  
 对象值都是引用,对象的比较均是引用的比较:当且仅当它们引用同一个基对象时,它们才相等.  
## 3.8 类型转换  
 ![image](https://github.com/LovingStar/basis/blob/master/JavaScript-The%20Definitive%20Guide/IMAGE/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.PNG)  
 原始值到对象的转换:原始值通过调用String(),Number()或Boolean()构造函数,转换为它们各自的包装对象.  
 null和undefined属于例外,当将它们用在期望是一个对象的地方都会造成一个类型错误异常,而不会执行正常的转换.  
#### 3.8.1 转换和相等性  
 JavaScript可以做灵活的类型转换.  
 "=="等于运算符在判断两个值是否相等时做了一些类型转换,但"=="运算符从不试图将其操作数转换为布尔值.  
 "==="恒等运算符在判断相等时并未做任何类型转换.  
 一个值转换为另一个值,并不意味着两个值相等.如:如果在期望使用布尔值的地方使用了undefined,它将会转换为false,但这并不表明undefined==false.  
#### 3.8.2 显示类型转换  
 使用Boolean(),Number(),String()或Object()函数做**显示类型转换**.  
 ```  
 Number("3")      //=>3  A
 String(false)    //=>"false"或使用false.toString()  
 Boolean([])      //=>true  
 Object(3)        //=>new Number(3)  
 ```  
 JavaScript中的某些运算符会做隐式地类型转换,有时用于类型转换.  
 ```  
 x+""    //等价于String(x)  
 +x      //等价于Number(x).也可以写成 x-0  
 !!x     //等价于Boolean(x).注意是双叹号  
 ```  
 Number类定义的toString()方法可以接收表示转换基数的**可选参数**,如果不指定此参数,转换规则将是基于十进制.  
 parseInt()可以接收第二个可选参数,这个参数指定数字转换的技术,合法的取值范围是2~36.  
 
#### 3.8.3 对象转换为原始值  
 对象到布尔值的转换非常简单:所有的对象(包括数组和函数)都转换为true.对于包装对象也是如此.  
 所有的对象继承了两个转换方法,第一个是toString(),返回一个反映这个对象的字符串;另一个是valueOf(),简单地返回对象本身,而不是返回一个原始值.  
 JavaScript中对象到字符串的转换经过如下步骤:  
 
 1. 若果对象具有toString()方法,则调用这个方法.  
 2. 如果对象没有toString()方法,或者这个对象并不返回一个原始值,那么JavaScript会调用valueOf()方法.  
 3. 否则,JavaScript无法从toString()或valueOf()获得一个原始值,因此这时它将抛出一个类型错误异常. 
 
在对象到数字的转换过程中,JavaScript做了同样的事情,只是它会首先尝试使用valueOf()方法.  
 
## 3.9 变量声明  
 静态类型语言:C,C++,JAVA,C#. 数据类型在编译期间检查,程序要声明变量的数据类型.  
 动态类型语言:Python,Ruby,JavaScript.JavaScript在变量声明中并没有指定变量的数据类型(可以是任意数据类型).  
 **重复的声明**:合法且无害,也就是简单的赋值语句.  
 **遗漏的声明**:尽量不要给一个未声明的变量赋值.(虽然在ECMAScript之前不会报错)  
 
## 3.10 变量作用域  
 在函数体内,局部变量的优先级高于同名的全局变量.  
 尽管在全局作用域编写代码时可以不写var语句,但声明局部变量时则必须使用var语句.  
 
#### 3.10.1 函数作用域和声明提前  
 **函数作用域**:变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的.  
 JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的.这意味着变量在声明之前甚至已经可用.这个特性被称为**声明提前**,即JavaScript函数里声明的所有变量(但不涉及赋值)都被"提前"至函数体的顶部.  
 
#### 3.10.2 作为属性的变量  
 当使用var声明一个变量时,创建的这个属性是不可配置的,也就是说这个变量无法通过delete运算符删除.  
 如果没有使用严格模式并给一个未声明的变量赋值的话,JavaScript会自动创建一个全局变量,以这种方式创建的变量是全局对象的正常的可配置属性,并可以删除它们.  
 JavaScript全局变量是全局对象的属性.[有规定]局部变量当做跟函数调用相关的某个对象的属性.[无规定]  
 JavaScript中允许使用this关键字来引用全局对象,却没有方法可以引用局部变量中存放的对象.  
 
#### 3.10.3 作用域链  
 每一段JavaScript代码(全局代码或函数)都有一个与之相关联的作用域链.这个作用域链是一个对象列表或者链表,这组对象定义了这段代码"作用域中"的变量.  
 
 1. 在JavaScript的最顶层代码中(也就是不包含在任何函数定义内的代码),作用域链由一个全局对象组成.  
 2. 在不包含嵌套的函数体内,作用域链上有两个对象,第一个是定义函数参数和局部变量的对象,第二个是全局对象.  
 3. 在一个嵌套的函数体内,作用域链上至少有三个对象.  
 
作用域链的概念对于理解with语句和闭包的概念是非常有用的.
 
